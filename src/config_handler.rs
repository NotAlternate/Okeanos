use std::{collections::HashMap, env, path::Path, ffi::CString, os::raw::c_int, process::exit, fs::File, io::Write};
use crate::{strings, utility};
use {libc, sudo};

#[allow(deprecated)]
pub fn check_config(sys: bool) -> bool { Path::new(&format!("{}/.okeanos_profile", if sys { "/etc".to_string() } else { env::home_dir().unwrap().to_string_lossy().to_string() })).exists() }

pub struct Configurations<'a> {
    pub data: HashMap<&'a str, HashMap<&'a str, HashMap<&'a str, String>>>,
    pub existence: bool,
} impl Configurations<'_> {
    pub fn new() -> Self {
        let information = strings::information();

        let mut existence = false;

        match check_config(true) {
            true => { match check_config(false) {
                true => existence = true,
                false => {
                    utility::clear_screen();
                    if utility::prompt_input(&information["noUserProfile"]) { create_configuration(false); }
                    else { existence = true; }
                }
            }},
            false => {
                utility::clear_screen();
                if utility::prompt_input(&information["noSystemProfile"]) { create_configuration(true); }
                else {
                    println!("{}", strings::warnings()["profileMaybeDeleted"]);
                    if utility::prompt_input(&information["reqGenerateProfile"]) {
                        create_configuration(true);
                    }
                }
            }
        }

        // Retriving data from both system-wide and user configurations
        let data = HashMap::new();

        Self { data, existence }
    }
    pub fn check(&mut self) {
        match check_config(false) {
            true => { match check_config(true) {
                true => self.existence = true,
                false => { if self.existence { println!("{}", strings::warnings()["missingSysProfile"]); }}
            }},
            false => { if self.existence { println!("{}", strings::warnings()["missingUserProfile"]); }}
        }
    }
}


#[allow(temporary_cstring_as_ptr)] // no (catastrophic) errors yet, no need for more safety
#[allow(deprecated)]
fn create_configuration(sys: bool) {
    let notes = strings::note(); let errors = strings::errors();
    if sys { // Elevating privileges using sudo if insufficient.
        match unsafe { libc::access(CString::new("/etc/").unwrap().as_ptr(), libc::W_OK as c_int) } {
            0 => println!("{}", notes["sufficientPrivileges"]),
            _ => {
                println!("{}\n{}", errors["insufficientPrivileges"], notes["requirePrivileges"]);
                utility::prompt_wait(&notes["requirePrompt"]);
                if sudo::escalate_if_needed().is_ok() { println!("{}", notes["privilegesElevated"]); }
                else { eprintln!("{}", errors["sudoElevateFail"]); exit(-1); }
            }
        };
    }

    println!("{}", notes["generatingProfile"]);
    match File::create(Path::new(&format!("{}/.okeanos_profile", if sys { "/etc".to_string() } else { env::home_dir().unwrap().to_string_lossy().to_string() }))) {
        Ok(mut file) => { match file.write_all((if sys {"
            # Auto generated by Okeanos
            [okeanos]
            PATH = \"/usr/bin:/usr/local/bin\"
        "} else /* above for system-wide, below for user conf */ {"
            # Auto generated by Okeanos
            [okeanos]
            PATH = \"\" # Add your own PATH, separate directories with `:`
        "}).trim_start_matches('\n').replace("            ", "").replace("        ", "").as_bytes()) {
            Ok(_) => (),
            Err(e) => { eprintln!("{} :: {}", errors["fileWriteFail"], e); exit(-1); }
        }},
        Err(e) => { eprintln!("{} :: {}", errors["fileCreationFail"], e); exit(-1); }
    }
    utility::prompt_wait(&strings::information()[if sys { "generationCompleteSys" } else { "generationCompleteUser" }]); if sys { exit(0); }
}